# Content Scripts

Content scripts run in the context of web pages.

### Use cases:

- Scraping data from the current web page
- Selecting, finding, and styling elements from the current web page
- [Injecting UI elements into the current web page](/browser-extension/content-scripts-ui)

## Adding a single content script

> **NOTE:** Since Plasmo's default Typescript configuration treats all source files as modules, if you don't have any imports or exports in your code, you'll have to add an `export {}` line at the start of your file. (You will see this warning when creating your first content script!)

Create a `content.ts` file that exports an empty object and hack away! See [with-content-script](https://github.com/PlasmoHQ/examples/tree/main/with-content-script) for an example.

## Adding multiple content scripts

Create a `contents` directory for multiple content scripts, and add your content scripts there. See [with-many-content-scripts](https://github.com/PlasmoHQ/examples/tree/main/with-many-content-scripts) for an example.

## Customizing content script config

To provide a custom content script configuration, such as matching a custom domain per script, setting the `all_frames` key, etc., export a config object from your content script:

```ts
import type { PlasmoContentScript } from "plasmo"

export const config: PlasmoContentScript = {
  matches: ["<all_urls>"],
  all_frames: true
}
```

Working with this configuration object is a breeze thanks to the exported `PlasmoContentScript` type ðŸ¥³.

## Injecting into the main world

You must inject code into the main world if you'd like to access the `window` object from your content script. It's not currently possible to declaratively inject content scripts into the main world via the `content_scripts` manifest field.

Instead, Chrome offers a `chrome.scripting.executeScript` API that lets you inject content scripts into the main world. First add the scripting permission into your manifest:

```json
{
  "permissions": ["scripting"]
}
```

Then, you can inject your content script into the main world by calling `chrome.scripting.executeScript` from your background service worker:

```ts
chrome.scripting.executeScript(
  {
    target: {
      tabId // the tab you want to inject into
    },
    world: "MAIN", // MAIN to access the window object
    func: windowChanger // function to inject
  },
  () => {
    console.log("Background script got callback after injection")
  }
)
```

For the `func` key, you can pass in a Typescript function from your project, which will automatically convert to a JavaScript function when your extension bundles.

See [with-main-world-content-script-injection](https://github.com/PlasmoHQ/examples/tree/main/with-main-world-content-script-injection) for an example.

### Importing Web Accessible Resources

To import external assets into your content script, you can use the `url:` scheme:

```ts
import myJavascriptFile from "url:./path/to/my/file/something.js"
```

The `url:` scheme will automatically resolve the `something.js` asset and add it to the `web_accessible_resources` declaration in the built bundle. What is the value of `myJavascriptFile`?

```sh
> console.log(myJavascriptFile)

chrome-extension://<your chrome ext id>/something.eb20bc99.js?1656000646313
```

The imported variable is a string that points to the path of the resource. You can now access that file however you'd like!

Alternatively, you can use the `data-base64` or the `data-text` scheme to import and embed the asset directly into your code. For small assets, these schemes should work well.

> NOTE: Please see this [note about `~` import resolution](/workflows/faq#tilde-import-resolution)
