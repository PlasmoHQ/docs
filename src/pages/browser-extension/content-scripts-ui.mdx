# Content Script UI

Plasmo has first-class support for mounting React, Svelte3, or Vue3 components into the current webpage. This feature is called content scripts UI (CSUI).

An extension can have as many CSUI as needed, with each CSUI targeting a group of webpages or a specific webpage by [exporting the config object](/browser-extension/content-scripts#config). To start injecting UI using React:

0. Create a `contents` directory if you don't have one already.
1. Create a new file inside `contents` directory with the `.tsx` extension: `contents/inline.tsx`
2. Export default a React component:

```tsx
const PlasmoInline = () => {
  return <button>Custom button</button>
}

export default PlasmoInline
```

3. Profit ðŸŽ‰

> NOTE: It works with a `content.tsx` at the source code directory as well.

See [with-content-scripts-ui](https://github.com/PlasmoHQ/examples/tree/main/with-content-scripts-ui)

### How does Plasmo mount the UI component?

Plasmo creates a [Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM) and mounts the component onto it. This isolation technique prevents the web page's style from affecting the component's styling.

### Config

Content scripts UI are a sub-set of content scripts. Thus, you can [export a config object](/browser-extension/content-scripts#config).

## getStyle

To inject stylesheets into your content script UI's Shadow DOM, export a `getStyle` function that returns a valid [`HTMLElement.style`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style) element:

```ts
import cssText from "data-text:~/contents/plasmo-overlay.css"

export const getStyle = () => {
  const style = document.createElement("style")
  style.textContent = cssText
  return style
}
```

Plasmo appends the style element into the Shadow DOM before the exported component's container.

See [the plasmo-overlay.tsx file in with-content-scripts-ui](https://github.com/PlasmoHQ/examples/blob/main/with-content-scripts-ui/contents/plasmo-overlay.tsx) for an example.

### Note about `data-text` schemes

In the example above, we use the [`data-text`](/browser-extension/import#data-text) scheme to load our stylesheet as plain text into the `cssText` variable, which we then assign to our style element's `textContent`. Be cautious with this scheme's import path if you use the `src` directory, as noted [here](/browser-extension/import#tilde-).

### Styling the shadows

Use the ids `#plasmo-mount-container` and `#plasmo-shadow-container` to tweak the style of these shadowDOM containers in your css:

```css
#plasmo-shadow-container {
  z-index: 99999;
}

#plasmo-mount-container {
  background: blue;
}
```

### Using a custom Font

To use a custom font in your CSUI, you must import the font inside a css file and declare it in the `css` property of the [config object](/browser-extension/content-scripts#config). The reason is that font assets are not recognized by the browser if declared inside a shadowDOM; they must be loaded into the global scope. Follow the steps below:

1. Add your font in the `assets` directory, e.g `/assets/Fascinate.woff2`
2. Create a `font.css` file, importing the font inline using the [`data-base64`](/browser-extension/import#data-base64) scheme:

```css
@font-face {
  font-family: "Fascinate";
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(data-base64:~assets/Fascinate.woff2) format("woff2");
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA,
    U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215,
    U+FEFF, U+FFFD;
}
```

3. Declare the file in the `css` property in the config:

```tsx
export const config: PlasmoContentScript = {
  matches: ["https://www.plasmo.com/*"],
  css: ["font.css"]
}
```

Once the font is registered by the browser, you can reference it inside your CSS style:

```css
.hw-top {
  background: red;
  color: white;
  font-family: "Fascinate";
}
```

See [with-content-scripts-ui/contents/plasmo-overlay.tsx](https://github.com/PlasmoHQ/examples/blob/main/with-content-scripts-ui/contents/plasmo-overlay.tsx)

## getOverlayAnchor

To anchor a React component on top of a specific element on the current webpage, export a function called `getOverlayAnchor` that returns a valid [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement):

```tsx
import type { PlasmoGetOverlayAnchor } from "plasmo"

export const getOverlayAnchor: PlasmoGetOverlayAnchor = async () =>
  document.querySelector("#element")
```

This function is asynchronous, which allows you to wait until the element exists. It is also agnostic. You can send the current webpage to a remote API via fetch to calculate the element selector, then query and return that element. The possibilities are endless!

Check [this file in with-content-scripts-ui](https://github.com/PlasmoHQ/examples/blob/main/with-content-scripts-ui/contents/plasmo-mount.tsx) for an example.

### How does getOverlayAnchor works?

`getOverlayAnchor` first listens to the current window's scroll event. On each scroll event, it uses the `getBoundingClientRect` function to calculate the absolute position of the target element. Then, it applies the calculated position to the container used to mount your component.

### watchOverlayAnchor

Exporting a `watchOverlayAnchor` function allows the developer to refresh the overlay position using the passed-down `updatePosition` callback whenever necessary. The example below refreshes the position every 8472ms:

```ts
import type { PlasmoWatchOverlayAnchor } from "plasmo"

export const watchOverlayAnchor: PlasmoWatchOverlayAnchor = (
  updatePosition
) => {
  setInterval(() => {
    updatePosition()
  }, 8472)
}
```

## getInlineAnchor

To anchor a React component inline with a specific element on the current webpage, export a function called `getInlineAnchor` that returns a valid [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement):

```tsx
import type { PlasmoGetInlineAnchor } from "plasmo"

export const getInlineAnchor: PlasmoGetInlineAnchor = () =>
  document.querySelector("#supercharge > h2 > span")
```

`getInlineAnchor` must be synchronous since Plasmo invokes it inside a MutationObserver that watches over the entire web page's DOM. Plasmo's observer instance will continue monitoring the shadow host to re-mount it as needed.

### How does getInlineAnchor detects if my component is mounted?

If a [shadowHostId](#getshadowhostid) is provided, Plasmo will query it using the `document.getElementById` lookup every observer callback. Otherwise, Plasmo will use `getRootNode`, which traces the DOM tree upwards until it finds the root node and compares it to the page's root document.

## getShadowHostId

In some cases, we might want to make runtime changes to the shadow host. By exporting a `getShadowHostId` function (optionally async), we can assign the shadow host's DOM ID, which will allow us to select and modify it:

```tsx
import type { PlasmoGetShadowHostId } from "plasmo"

export const getShadowHostId: PlasmoGetShadowHostId = () => "custom-shadow-host"
```

This will also optimize the performance of the inline anchor function since it will no longer need to traverse the DOM tree upwards to find the root node.

## mountShadowHost

By default, Plasmo will mount the `shadowHost` adjacent after-end relative to the inline anchor. However, if you want to customize how it should mount the `shadowHost`, export a `mountShadowHost` function. The example below add the `shadowHost` as a child of the inlineAnchor instead of being siblings:

```tsx
import type { PlasmoMountShadowHost } from "plasmo"

export const mountShadowHost: PlasmoMountShadowHost = ({
  shadowHost,
  inlineAnchor
}) => {
  inlineAnchor.appendChild(shadowHost)
}
```

The `mountShadowHost` function also receives the observer instance, allowing you to stop the observer as needed:

```tsx
import type { PlasmoMountShadowHost } from "plasmo"

export const mountShadowHost: PlasmoMountShadowHost = ({
  shadowHost,
  inlineAnchor,
  observer
}) => {
  // Do you custom mount...
  inlineAnchor.appendChild(shadowHost)
  observer.disconnect()
}
```

## createShadowRoot

By default, Plasmo creates an "open" shadowRoot and attach it to the shadowHost. To override this behavior and create a "closed" shadowRoot for example, export a `createShadowRoot` function. The first parameter will be the generated `shadowHost`:

```tsx
import type { PlasmoCreateShadowRoot } from "plasmo"

export const createShadowRoot: PlasmoCreateShadowRoot = (shadowHost) =>
  shadowHost.attachShadow({ mode: "closed" })
```

## getRootContainer

To replace the entire Shadow DOM implementation, export a `getRootContainer` function that returns a valid [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).

Use cases:

- Extension needs to [absorb the styling of the host webpage](https://github.com/PlasmoHQ/plasmo/issues/10#issuecomment-1149499252)
- Extension needs to mount the component directly into the webpage instead of using a shadow DOM

```ts
export const getRootContainer = () => {
  return document.querySelector("#feature")
}
```

> **NOTE:** If you export a `getRootContainer` function, Plasmo ignores the `getStyle` function since only the provided Shadow DOM container uses it. `getMountPoint`'s behavior might also be affected as the component's position will be relative to your provided container.

Check [this file in with-content-scripts-ui](https://github.com/PlasmoHQ/examples/blob/main/with-content-scripts-ui/contents/plasmo-root-container.tsx) for an example.

## render

The `render` function allows you to customize how Plasmo renders everything. Use it to override our implementation of the MutationObserver, our MountContainer, or both:

```ts
import type { PlasmoRender } from "plasmo"

export const render: PlasmoRender = (
  createRootContainer, // This creates the default root container
  MountContainer // This creates the default MountContainer
) => {
  const rootContainer = await createRootContainer()

  const soup = cookRoot(rootContainer)
  soup.render(<MountContainer />)
}
```
